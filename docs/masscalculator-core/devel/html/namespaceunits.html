<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>masscalculator-core: units Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">masscalculator-core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">units Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Unit Conversion Library namespace.  
<a href="namespaceunits.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceunits_1_1acceleration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1acceleration.html">acceleration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1acceleration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing acceleration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angle.html">angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angle values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1angular__velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1angular__velocity.html">angular_velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1angular__velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing angular velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1area"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1area.html">area</a></td></tr>
<tr class="memdesc:namespaceunits_1_1area"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing area values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1capacitance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1capacitance.html">capacitance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1capacitance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing capacitance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1category"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html">category</a></td></tr>
<tr class="memdesc:namespaceunits_1_1category"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing the implemented base and derived unit types. These will not generally be needed by library users. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1charge"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1charge.html">charge</a></td></tr>
<tr class="memdesc:namespaceunits_1_1charge"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing charge values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1concentration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1concentration.html">concentration</a></td></tr>
<tr class="memdesc:namespaceunits_1_1concentration"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing concentration values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1conductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1conductance.html">conductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1conductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing conductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespaceunits_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for physical constants like PI and Avogadro's Number. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1current"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1current.html">current</a></td></tr>
<tr class="memdesc:namespaceunits_1_1current"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing current values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1data"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1data.html">data</a></td></tr>
<tr class="memdesc:namespaceunits_1_1data"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing data values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1data__transfer__rate"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1data__transfer__rate.html">data_transfer_rate</a></td></tr>
<tr class="memdesc:namespaceunits_1_1data__transfer__rate"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing data values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1density"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1density.html">density</a></td></tr>
<tr class="memdesc:namespaceunits_1_1density"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing density values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1dimensionless"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html">dimensionless</a></td></tr>
<tr class="memdesc:namespaceunits_1_1dimensionless"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers for units that have no dimension (scalar units) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1energy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1energy.html">energy</a></td></tr>
<tr class="memdesc:namespaceunits_1_1energy"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing energy values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1force"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1force.html">force</a></td></tr>
<tr class="memdesc:namespaceunits_1_1force"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing force values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1frequency"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1frequency.html">frequency</a></td></tr>
<tr class="memdesc:namespaceunits_1_1frequency"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing frequency values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1illuminance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1illuminance.html">illuminance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1illuminance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing illuminance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1impedance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1impedance.html">impedance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1impedance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing impedance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1inductance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1inductance.html">inductance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1inductance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing inductance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1length"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1length.html">length</a></td></tr>
<tr class="memdesc:namespaceunits_1_1length"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing length values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:namespaceunits_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit literal definitions of all categories. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__flux.html">luminous_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__flux.html" title="namespace for unit types and containers representing luminous_flux values">luminous_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1luminous__intensity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1luminous__intensity.html">luminous_intensity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1luminous__intensity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1luminous__intensity.html" title="namespace for unit types and containers representing luminous_intensity values">luminous_intensity</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__field__strength"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__field__strength.html">magnetic_field_strength</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__field__strength"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__field__strength.html" title="namespace for unit types and containers representing magnetic_field_strength values">magnetic_field_strength</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1magnetic__flux"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1magnetic__flux.html">magnetic_flux</a></td></tr>
<tr class="memdesc:namespaceunits_1_1magnetic__flux"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1magnetic__flux.html" title="namespace for unit types and containers representing magnetic_flux values">magnetic_flux</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1mass"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1mass.html">mass</a></td></tr>
<tr class="memdesc:namespaceunits_1_1mass"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing mass values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespaceunits_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit-enabled versions of the <code>&lt;cmath&gt;</code> library <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1power"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1power.html">power</a></td></tr>
<tr class="memdesc:namespaceunits_1_1power"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing power values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1pressure"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1pressure.html">pressure</a></td></tr>
<tr class="memdesc:namespaceunits_1_1pressure"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing pressure values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1radiation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1radiation.html">radiation</a></td></tr>
<tr class="memdesc:namespaceunits_1_1radiation"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing radiation values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1solid__angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1solid__angle.html">solid_angle</a></td></tr>
<tr class="memdesc:namespaceunits_1_1solid__angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing <a class="el" href="namespaceunits_1_1solid__angle.html" title="namespace for unit types and containers representing solid_angle values">solid_angle</a> values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1substance"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1substance.html">substance</a></td></tr>
<tr class="memdesc:namespaceunits_1_1substance"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing substance values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1temperature"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1temperature.html">temperature</a></td></tr>
<tr class="memdesc:namespaceunits_1_1temperature"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing temperature values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1time"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1time.html">time</a></td></tr>
<tr class="memdesc:namespaceunits_1_1time"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing time values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1torque"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1torque.html">torque</a></td></tr>
<tr class="memdesc:namespaceunits_1_1torque"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing torque values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespaceunits_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing type traits which can access the properties of types provided by the units library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1velocity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1velocity.html">velocity</a></td></tr>
<tr class="memdesc:namespaceunits_1_1velocity"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing velocity values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1voltage"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1voltage.html">voltage</a></td></tr>
<tr class="memdesc:namespaceunits_1_1voltage"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing voltage values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceunits_1_1volume"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1volume.html">volume</a></td></tr>
<tr class="memdesc:namespaceunits_1_1volume"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers representing volume values <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1base__unit.html">base_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing SI base unit types.  <a href="structunits_1_1base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> scale for representing decibel values.  <a href="structunits_1_1decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1linear__scale.html">linear_scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> scale which is linear  <a href="structunits_1_1linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit.html">unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing an arbitrary unit.  <a href="structunits_1_1unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunits_1_1unit__t.html">unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for values which represent quantities of a given unit.  <a href="classunits_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__add.html">unit_value_add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__divide.html">unit_value_divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">divides two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__multiply.html">unit_value_multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__power.html">unit_value_power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises unit_value_to a power at compile-time  <a href="structunits_1_1unit__value__power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__sqrt.html">unit_value_sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates square root of <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> at compile-time  <a href="structunits_1_1unit__value__sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__subtract.html">unit_value_subtract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__subtract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__t.html">unit_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a rational unit value as a compile-time constant.  <a href="structunits_1_1unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a> = typename units::detail::inverse_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the inverse unit type of <code>class U</code>.  <a href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">More...</a><br /></td></tr>
<tr class="separator:ga18b87c9f4576fb72ddc0b2a516a42d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38048bc5246636a5eb0007262475dc38"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga38048bc5246636a5eb0007262475dc38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitManipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a> = typename units::detail::squared_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga38048bc5246636a5eb0007262475dc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the unit type of <code>class U</code> squared  <a href="group__UnitManipulators.html#ga38048bc5246636a5eb0007262475dc38">More...</a><br /></td></tr>
<tr class="separator:ga38048bc5246636a5eb0007262475dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4278ee8cb796f22534570134325a4d52"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga4278ee8cb796f22534570134325a4d52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitManipulators.html#ga4278ee8cb796f22534570134325a4d52">cubed</a> = typename units::detail::cubed_impl&lt; U &gt;::type</td></tr>
<tr class="memdesc:ga4278ee8cb796f22534570134325a4d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the type of <code>class U</code> cubed.  <a href="group__UnitManipulators.html#ga4278ee8cb796f22534570134325a4d52">More...</a><br /></td></tr>
<tr class="separator:ga4278ee8cb796f22534570134325a4d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17385adb4c49d5c70168bbaba780559b"><td class="memTemplParams" colspan="2">template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:ga17385adb4c49d5c70168bbaba780559b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TypeTraits.html#ga17385adb4c49d5c70168bbaba780559b">ratio_sqrt</a> = typename units::detail::Sqrt&lt; Ratio, std::ratio&lt; 1, Eps &gt; &gt;::type</td></tr>
<tr class="memdesc:ga17385adb4c49d5c70168bbaba780559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate square root of a ratio at compile-time.  <a href="group__TypeTraits.html#ga17385adb4c49d5c70168bbaba780559b">More...</a><br /></td></tr>
<tr class="separator:ga17385adb4c49d5c70168bbaba780559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memTemplParams" colspan="2">template&lt;class U , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitManipulators.html#gad6fb385c468a9f9956d23ebc7c38523a">square_root</a> = typename units::detail::sqrt_impl&lt; U, Eps &gt;::type</td></tr>
<tr class="memdesc:gad6fb385c468a9f9956d23ebc7c38523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the square root of type <code>class U</code>.  <a href="group__UnitManipulators.html#gad6fb385c468a9f9956d23ebc7c38523a">More...</a><br /></td></tr>
<tr class="separator:gad6fb385c468a9f9956d23ebc7c38523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memTemplParams" colspan="2">template&lt;class U , class... Us&gt; </td></tr>
<tr class="memitem:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a> = typename units::detail::compound_impl&lt; U, Us... &gt;::type</td></tr>
<tr class="memdesc:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit type made up from other units.  <a href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">More...</a><br /></td></tr>
<tr class="separator:ga36d8b8cf508bd5ac7854d15f6eaf2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72c34dfc4c00daf2ffe858e58d4801aa"><td class="memTemplParams" colspan="2"><a id="a72c34dfc4c00daf2ffe858e58d4801aa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72c34dfc4c00daf2ffe858e58d4801aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>name</b> (const T &amp;)</td></tr>
<tr class="separator:a72c34dfc4c00daf2ffe858e58d4801aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910be27826d9766520b1f8e07e29d944"><td class="memTemplParams" colspan="2"><a id="a910be27826d9766520b1f8e07e29d944"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a910be27826d9766520b1f8e07e29d944"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abbreviation</b> (const T &amp;)</td></tr>
<tr class="separator:a910be27826d9766520b1f8e07e29d944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memTemplParams" colspan="2">template&lt;class UnitType , typename T , class  = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UnitContainers.html#ga1acd69ada7a93c35850717e3c1b4d5fc">make_unit</a> (const T value) noexcept</td></tr>
<tr class="memdesc:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a unit container from an arithmetic type.  <a href="group__UnitContainers.html#ga1acd69ada7a93c35850717e3c1b4d5fc">More...</a><br /></td></tr>
<tr class="separator:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b80311df9f6be8c0e13c094b83d414"><td class="memTemplParams" colspan="2"><a id="a19b80311df9f6be8c0e13c094b83d414"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a19b80311df9f6be8c0e13c094b83d414"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;obj) noexcept</td></tr>
<tr class="separator:a19b80311df9f6be8c0e13c094b83d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a77d4dc029114ff64019f1bbe6a5cb"><td class="memTemplParams" colspan="2"><a id="a76a77d4dc029114ff64019f1bbe6a5cb"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:a76a77d4dc029114ff64019f1bbe6a5cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:a76a77d4dc029114ff64019f1bbe6a5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09ae9f5fbe1682724dead619a9b305a"><td class="memTemplParams" colspan="2"><a id="ac09ae9f5fbe1682724dead619a9b305a"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:ac09ae9f5fbe1682724dead619a9b305a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:ac09ae9f5fbe1682724dead619a9b305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf85b4411bb623531fda9264c95168de"><td class="memTemplParams" colspan="2"><a id="aaf85b4411bb623531fda9264c95168de"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:aaf85b4411bb623531fda9264c95168de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:aaf85b4411bb623531fda9264c95168de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59607d938c6ee633c8a0f912f0a07d5"><td class="memTemplParams" colspan="2"><a id="ab59607d938c6ee633c8a0f912f0a07d5"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:ab59607d938c6ee633c8a0f912f0a07d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:ab59607d938c6ee633c8a0f912f0a07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf9091d64bb9ef03ce989f495562ac2"><td class="memTemplParams" colspan="2"><a id="abcf9091d64bb9ef03ce989f495562ac2"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:abcf9091d64bb9ef03ce989f495562ac2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:abcf9091d64bb9ef03ce989f495562ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4393e791795fac85f9881bd7590a510"><td class="memTemplParams" colspan="2"><a id="ac4393e791795fac85f9881bd7590a510"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:ac4393e791795fac85f9881bd7590a510"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator++</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:ac4393e791795fac85f9881bd7590a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23b448168166aed4175543771208df7"><td class="memTemplParams" colspan="2"><a id="ad23b448168166aed4175543771208df7"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:ad23b448168166aed4175543771208df7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator++</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u, int) noexcept</td></tr>
<tr class="separator:ad23b448168166aed4175543771208df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387bcdb847fb3fec5f4b85359142dedd"><td class="memTemplParams" colspan="2"><a id="a387bcdb847fb3fec5f4b85359142dedd"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a387bcdb847fb3fec5f4b85359142dedd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:a387bcdb847fb3fec5f4b85359142dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11e544131ee88812f8d4f410895dda"><td class="memTemplParams" colspan="2"><a id="a8f11e544131ee88812f8d4f410895dda"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a8f11e544131ee88812f8d4f410895dda"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator--</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:a8f11e544131ee88812f8d4f410895dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcb19261f77e36642e381823702e273"><td class="memTemplParams" colspan="2"><a id="abfcb19261f77e36642e381823702e273"></a>
template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:abfcb19261f77e36642e381823702e273"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator--</b> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u, int) noexcept</td></tr>
<tr class="separator:abfcb19261f77e36642e381823702e273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850c3e5c380d1eb1d718128966819c70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Units , class  = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp; traits::is_unit_t&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga850c3e5c380d1eb1d718128966819c70"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Conversion.html#ga850c3e5c380d1eb1d718128966819c70">unit_cast</a> (const Units &amp;value) noexcept</td></tr>
<tr class="memdesc:ga850c3e5c380d1eb1d718128966819c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a unit container to an arithmetic type.  <a href="group__Conversion.html#ga850c3e5c380d1eb1d718128966819c70">More...</a><br /></td></tr>
<tr class="separator:ga850c3e5c380d1eb1d718128966819c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memTemplParams" colspan="2"><a id="a81cb11390bc6db4d4b3ceb9f098969d9"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt;!traits::is_same_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const UnitTypeLhs &amp;, const UnitTypeRhs &amp;) noexcept</td></tr>
<tr class="separator:a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71b68052438b9369f3d1a32f7928f2"><td class="memTemplParams" colspan="2"><a id="a3a71b68052438b9369f3d1a32f7928f2"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3a71b68052438b9369f3d1a32f7928f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a3a71b68052438b9369f3d1a32f7928f2">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a71b68052438b9369f3d1a32f7928f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. <br /></td></tr>
<tr class="separator:a3a71b68052438b9369f3d1a32f7928f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memTemplParams" colspan="2"><a id="a0e70fbe82fa3e174bec8df6a82978ee3"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a0e70fbe82fa3e174bec8df6a82978ee3">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb285c204ca46e6e01fd60acbfffb4e2"><td class="memTemplParams" colspan="2"><a id="abb285c204ca46e6e01fd60acbfffb4e2"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abb285c204ca46e6e01fd60acbfffb4e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#abb285c204ca46e6e01fd60acbfffb4e2">operator+</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abb285c204ca46e6e01fd60acbfffb4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:abb285c204ca46e6e01fd60acbfffb4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276f124efd1553bb3ecc7272e89fc00"><td class="memTemplParams" colspan="2"><a id="a1276f124efd1553bb3ecc7272e89fc00"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1276f124efd1553bb3ecc7272e89fc00"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1276f124efd1553bb3ecc7272e89fc00">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1276f124efd1553bb3ecc7272e89fc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. <br /></td></tr>
<tr class="separator:a1276f124efd1553bb3ecc7272e89fc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memTemplParams" colspan="2"><a id="a620cdb55bb08bc52fd25e6c7b5747ff5"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a620cdb55bb08bc52fd25e6c7b5747ff5">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c40cb31fd4fda534f293016693c221"><td class="memTemplParams" colspan="2"><a id="ad4c40cb31fd4fda534f293016693c221"></a>
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad4c40cb31fd4fda534f293016693c221"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ad4c40cb31fd4fda534f293016693c221">operator-</a> (T lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad4c40cb31fd4fda534f293016693c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types. <br /></td></tr>
<tr class="separator:ad4c40cb31fd4fda534f293016693c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0adfd2a8af2afee51393b486df7d6d"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8f0adfd2a8af2afee51393b486df7d6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a8f0adfd2a8af2afee51393b486df7d6d">operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; <a class="el" href="group__UnitManipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8f0adfd2a8af2afee51393b486df7d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <a href="namespaceunits.html#a8f0adfd2a8af2afee51393b486df7d6d">More...</a><br /></td></tr>
<tr class="separator:a8f0adfd2a8af2afee51393b486df7d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae149d36dcf39ce19af1bc6e0538415a2"><td class="memTemplParams" colspan="2"><a id="ae149d36dcf39ce19af1bc6e0538415a2"></a>
template&lt;class UnitTypeLhs , typename UnitTypeRhs , std::enable_if_t&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value &amp;&amp;traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae149d36dcf39ce19af1bc6e0538415a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae149d36dcf39ce19af1bc6e0538415a2">operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae149d36dcf39ce19af1bc6e0538415a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:ae149d36dcf39ce19af1bc6e0538415a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e5766d8297c69e324996f9a008ff60"><td class="memTemplParams" colspan="2"><a id="ae0e5766d8297c69e324996f9a008ff60"></a>
template&lt;class UnitTypeLhs , typename UnitTypeRhs , std::enable_if_t&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae0e5766d8297c69e324996f9a008ff60"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae0e5766d8297c69e324996f9a008ff60">operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae0e5766d8297c69e324996f9a008ff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:ae0e5766d8297c69e324996f9a008ff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca29120f8a80d0920f22ffb1615df4"><td class="memTemplParams" colspan="2"><a id="a56ca29120f8a80d0920f22ffb1615df4"></a>
template&lt;class UnitTypeLhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56ca29120f8a80d0920f22ffb1615df4"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a56ca29120f8a80d0920f22ffb1615df4">operator*</a> (const UnitTypeLhs &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a56ca29120f8a80d0920f22ffb1615df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a56ca29120f8a80d0920f22ffb1615df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ba3108188a585bb67c3f213e1c1b8"><td class="memTemplParams" colspan="2"><a id="a327ba3108188a585bb67c3f213e1c1b8"></a>
template&lt;class UnitTypeRhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a327ba3108188a585bb67c3f213e1c1b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a327ba3108188a585bb67c3f213e1c1b8">operator*</a> (T lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a327ba3108188a585bb67c3f213e1c1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:a327ba3108188a585bb67c3f213e1c1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277ba3ab0b1d897f5bd59de7854163b"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8277ba3ab0b1d897f5bd59de7854163b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a8277ba3ab0b1d897f5bd59de7854163b">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8277ba3ab0b1d897f5bd59de7854163b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <a href="namespaceunits.html#a8277ba3ab0b1d897f5bd59de7854163b">More...</a><br /></td></tr>
<tr class="separator:a8277ba3ab0b1d897f5bd59de7854163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ef13ab5aee54cce78a59813a306486"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a65ef13ab5aee54cce78a59813a306486"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a65ef13ab5aee54cce78a59813a306486">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a65ef13ab5aee54cce78a59813a306486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <a href="namespaceunits.html#a65ef13ab5aee54cce78a59813a306486">More...</a><br /></td></tr>
<tr class="separator:a65ef13ab5aee54cce78a59813a306486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27ef8903ff1a75260cb0489c12730e"><td class="memTemplParams" colspan="2"><a id="aef27ef8903ff1a75260cb0489c12730e"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value &amp;&amp;traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aef27ef8903ff1a75260cb0489c12730e"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aef27ef8903ff1a75260cb0489c12730e">operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aef27ef8903ff1a75260cb0489c12730e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:aef27ef8903ff1a75260cb0489c12730e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede70a4c0594d33f56f2390430dca1ed"><td class="memTemplParams" colspan="2"><a id="aede70a4c0594d33f56f2390430dca1ed"></a>
template&lt;class UnitTypeLhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aede70a4c0594d33f56f2390430dca1ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aede70a4c0594d33f56f2390430dca1ed">operator/</a> (const UnitTypeLhs &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:aede70a4c0594d33f56f2390430dca1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. <br /></td></tr>
<tr class="separator:aede70a4c0594d33f56f2390430dca1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7bac7fbfb7ea43bdb32c1ee1bd1b12"><td class="memTemplParams" colspan="2"><a id="a0a7bac7fbfb7ea43bdb32c1ee1bd1b12"></a>
template&lt;class UnitTypeRhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0a7bac7fbfb7ea43bdb32c1ee1bd1b12"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a0a7bac7fbfb7ea43bdb32c1ee1bd1b12">operator/</a> (T lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;</td></tr>
<tr class="memdesc:a0a7bac7fbfb7ea43bdb32c1ee1bd1b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar by a <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> type with a linear scale. <br /></td></tr>
<tr class="separator:a0a7bac7fbfb7ea43bdb32c1ee1bd1b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192892493e7f119568546508589c2fe"><td class="memTemplParams" colspan="2"><a id="a6192892493e7f119568546508589c2fe"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6192892493e7f119568546508589c2fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:a6192892493e7f119568546508589c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e57cc26790b07bc75699f339de10582"><td class="memTemplParams" colspan="2"><a id="a2e57cc26790b07bc75699f339de10582"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2e57cc26790b07bc75699f339de10582"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a2e57cc26790b07bc75699f339de10582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e6a0384e69f8cf0cc840183c407ec3"><td class="memTemplParams" colspan="2"><a id="a36e6a0384e69f8cf0cc840183c407ec3"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a36e6a0384e69f8cf0cc840183c407ec3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:a36e6a0384e69f8cf0cc840183c407ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deb49c3f7a5819462e2021e656932e2"><td class="memTemplParams" colspan="2"><a id="a7deb49c3f7a5819462e2021e656932e2"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7deb49c3f7a5819462e2021e656932e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a7deb49c3f7a5819462e2021e656932e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d26c3ef641666b95ad90b6a143fdd"><td class="memTemplParams" colspan="2"><a id="acd7d26c3ef641666b95ad90b6a143fdd"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acd7d26c3ef641666b95ad90b6a143fdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:acd7d26c3ef641666b95ad90b6a143fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9984d65cde63e7b97cfd8df035c50b7b"><td class="memTemplParams" colspan="2"><a id="a9984d65cde63e7b97cfd8df035c50b7b"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9984d65cde63e7b97cfd8df035c50b7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a9984d65cde63e7b97cfd8df035c50b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3d43d1395f155226a4c70e33f2e4a2"><td class="memTemplParams" colspan="2"><a id="add3d43d1395f155226a4c70e33f2e4a2"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:add3d43d1395f155226a4c70e33f2e4a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:add3d43d1395f155226a4c70e33f2e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b16156d9fd8964e7a54d7850ee13a88"><td class="memTemplParams" colspan="2"><a id="a6b16156d9fd8964e7a54d7850ee13a88"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6b16156d9fd8964e7a54d7850ee13a88"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a6b16156d9fd8964e7a54d7850ee13a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memTemplParams" colspan="2"><a id="acaa430d90dc65e5b3fc4ee81139aaf8d"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cf047daf09967c469e40a6e578a77a"><td class="memTemplParams" colspan="2"><a id="a20cf047daf09967c469e40a6e578a77a"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a20cf047daf09967c469e40a6e578a77a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a20cf047daf09967c469e40a6e578a77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3712beb53491526b997c043c33ef966"><td class="memTemplParams" colspan="2"><a id="aa3712beb53491526b997c043c33ef966"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aa3712beb53491526b997c043c33ef966"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const UNIT_LIB_DEFAULT_TYPE lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:aa3712beb53491526b997c043c33ef966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f7835cb09f1bdebe751c307d579208"><td class="memTemplParams" colspan="2"><a id="a53f7835cb09f1bdebe751c307d579208"></a>
template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a53f7835cb09f1bdebe751c307d579208"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const Units &amp;lhs, const UNIT_LIB_DEFAULT_TYPE rhs) noexcept</td></tr>
<tr class="separator:a53f7835cb09f1bdebe751c307d579208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299c7bec58ec2c51278a1482680d3b6"><td class="memTemplParams" colspan="2"><a id="a3299c7bec58ec2c51278a1482680d3b6"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3299c7bec58ec2c51278a1482680d3b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a3299c7bec58ec2c51278a1482680d3b6">operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; <a class="el" href="group__UnitManipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type &gt;&gt;, typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a3299c7bec58ec2c51278a1482680d3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a>. <br /></td></tr>
<tr class="separator:a3299c7bec58ec2c51278a1482680d3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b831b1b8478ee55f664d53272eeec23"><td class="memTemplParams" colspan="2"><a id="a9b831b1b8478ee55f664d53272eeec23"></a>
template&lt;class UnitTypeLhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9b831b1b8478ee55f664d53272eeec23"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a9b831b1b8478ee55f664d53272eeec23">operator+</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9b831b1b8478ee55f664d53272eeec23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a9b831b1b8478ee55f664d53272eeec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab69905978f40315a9d9a0041016f2e"><td class="memTemplParams" colspan="2"><a id="a1ab69905978f40315a9d9a0041016f2e"></a>
template&lt;class UnitTypeRhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ab69905978f40315a9d9a0041016f2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1ab69905978f40315a9d9a0041016f2e">operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1ab69905978f40315a9d9a0041016f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a1ab69905978f40315a9d9a0041016f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb5711b509c507bd74aedd1a030137e"><td class="memTemplParams" colspan="2"><a id="a8fb5711b509c507bd74aedd1a030137e"></a>
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8fb5711b509c507bd74aedd1a030137e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a8fb5711b509c507bd74aedd1a030137e">operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt;&gt;, typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a8fb5711b509c507bd74aedd1a030137e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a>. <br /></td></tr>
<tr class="separator:a8fb5711b509c507bd74aedd1a030137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4fae6a157a451266ef24407b130715"><td class="memTemplParams" colspan="2"><a id="aaf4fae6a157a451266ef24407b130715"></a>
template&lt;class UnitTypeLhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaf4fae6a157a451266ef24407b130715"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aaf4fae6a157a451266ef24407b130715">operator-</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aaf4fae6a157a451266ef24407b130715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:aaf4fae6a157a451266ef24407b130715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504674e253531cff43ca8a3dec8f4d2"><td class="memTemplParams" colspan="2"><a id="a5504674e253531cff43ca8a3dec8f4d2"></a>
template&lt;class UnitTypeRhs , std::enable_if_t&lt; traits::has_decibel_scale&lt; UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5504674e253531cff43ca8a3dec8f4d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a5504674e253531cff43ca8a3dec8f4d2">operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt;, typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a5504674e253531cff43ca8a3dec8f4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units. <br /></td></tr>
<tr class="separator:a5504674e253531cff43ca8a3dec8f4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unit Conversion Library namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8f0adfd2a8af2afee51393b486df7d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0adfd2a8af2afee51393b486df7d6d">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto units::operator* </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt;<a class="el" href="group__UnitManipulators.html#ga38048bc5246636a5eb0007262475dc38">squared</a>&lt;typename units::traits::unit_t_traits&lt;UnitTypeLhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. </p>
<p>Multiplication type for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.</p>
<dl class="section return"><dt>Returns</dt><dd>the multiplied value, with the same type as left-hand side unit.</dd>
<dd>
the multiplied value, whose type is a compound unit of the left and right hand side values. </dd></dl>

</div>
</div>
<a id="a8277ba3ab0b1d897f5bd59de7854163b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8277ba3ab0b1d897f5bd59de7854163b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunits_1_1unit__t.html">dimensionless::scalar_t</a> units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. </p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by rhs value, whose type is a scalar </dd></dl>

</div>
</div>
<a id="a65ef13ab5aee54cce78a59813a306486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ef13ab5aee54cce78a59813a306486">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt;!traits::is_convertible_unit_t&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;traits::has_linear_scale&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeLhs &gt;::value &amp;&amp;!traits::is_dimensionless_unit&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto units::operator/ </td>
          <td>(</td>
          <td class="paramtype">const UnitTypeLhs &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnitTypeRhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt;<a class="el" href="group__UnitTypes.html#ga36d8b8cf508bd5ac7854d15f6eaf2d7c">compound_unit</a>&lt;typename units::traits::unit_t_traits&lt;UnitTypeLhs&gt;::unit_type, <a class="el" href="group__UnitManipulators.html#ga18b87c9f4576fb72ddc0b2a516a42d41">inverse</a>&lt;typename units::traits::unit_t_traits&lt;UnitTypeRhs&gt;::unit_type&gt;&gt;&gt;
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale. </p>
<p>Division of a dimensionless unit by a <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> type with a linear scale.</p>
<dl class="section return"><dt>Returns</dt><dd>the lhs divided by the rhs, with a compound unit type of lhs/rhs </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
